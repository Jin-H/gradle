/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import data.Trie
import elmish.elementById
import elmish.mountComponentAt
import elmish.tree.Tree
import elmish.tree.TreeView
import kotlin.js.JSON.stringify


fun main() {
    mountComponentAt(
        elementById("report"),
        InstantExecutionReportPage,
        reportPageModelFromJsModel(instantExecutionFailures)
    )
}


/**
 * External model defined in `instant-execution-failures.js`, a file generated by `InstantExecutionReport`.
 */
private
external val instantExecutionFailures: JsModel


private
typealias JsModel = Array<JsFailure>


private
external interface JsFailure {
    val trace: Array<JsTrace>
    val message: Array<JsMessageFragment>
    val error: String?
}


private
external interface JsTrace {
    val kind: String
}


private
external interface JsTraceTask : JsTrace {
    val path: String
    val type: String
}


private
external interface JsTraceBean : JsTrace {
    val type: String
}


private
external interface JsTraceField : JsTrace {
    val name: String
    val declaringType: String
}


private
external interface JsTraceProperty : JsTrace {
    val name: String
    val task: String
}


private
external interface JsMessageFragment {
    val text: String?
    val name: String?
}


private
data class ImportedFailure(
    val failure: JsFailure,
    val message: PrettyText,
    val trace: List<FailureNode>
)


private
fun reportPageModelFromJsModel(jsFailures: JsModel): InstantExecutionReportPage.Model {
    val failures = jsFailures.map { jsFailure ->
        ImportedFailure(
            jsFailure,
            jsFailure.message.let(::toPrettyText),
            jsFailure.trace.map(::toFailureNode)
        )
    }
    return InstantExecutionReportPage.Model(
        totalFailures = instantExecutionFailures.size,
        messageTree = treeModelFor(
            FailureNode.Label("Failures grouped by message"),
            failureNodesByMessage(failures)
        ),
        taskTree = treeModelFor(
            FailureNode.Label("Failures grouped by task"),
            failureNodesByTask(failures)
        )
    )
}


private
fun failureNodesByMessage(failures: List<ImportedFailure>): Sequence<MutableList<FailureNode>> =
    failures.asSequence().map { imported ->
        mutableListOf<FailureNode>().apply {
            add(
                errorOrWarningNodeFor(
                    imported.failure,
                    messageNodeFor(imported)
                )
            )
            imported.trace.forEach { part ->
                add(part)
            }
            exceptionNodeFor(imported.failure)?.let {
                add(it)
            }
        }
    }


private
fun failureNodesByTask(failures: List<ImportedFailure>): Sequence<List<FailureNode>> =
    failures.asSequence().map { imported ->
        imported.trace.asReversed().mapIndexed { index, node ->
            when (index) {
                0 -> errorOrWarningNodeFor(imported.failure, node)
                else -> node
            }
        } + exceptionOrMessageNodeFor(imported)
    }


private
fun toPrettyText(message: Array<JsMessageFragment>) = PrettyText(
    message.map {
        it.text?.let(PrettyText.Fragment::Text)
            ?: it.name?.let(PrettyText.Fragment::Reference)
            ?: PrettyText.Fragment.Text("Unrecognised message fragment: ${stringify(it)}")
    }
)

private
fun toFailureNode(trace: JsTrace): FailureNode = when (val kind = trace.kind) {
    "Task" -> trace.unsafeCast<JsTraceTask>().run {
        FailureNode.Task(path, type)
    }
    "Bean" -> trace.unsafeCast<JsTraceBean>().run {
        FailureNode.Bean(type)
    }
    "Field" -> trace.unsafeCast<JsTraceField>().run {
        FailureNode.Property("field", name, declaringType)
    }
    "InputProperty" -> trace.unsafeCast<JsTraceProperty>().run {
        FailureNode.Property("input property", name, task)
    }
    "OutputProperty" -> trace.unsafeCast<JsTraceProperty>().run {
        FailureNode.Property("output property", name, task)
    }
    else -> FailureNode.Label("Gradle runtime")
}


private
fun errorOrWarningNodeFor(failure: JsFailure, label: FailureNode): FailureNode =
    failure.error?.let {
        FailureNode.Error(label)
    } ?: FailureNode.Warning(label)


private
fun exceptionOrMessageNodeFor(importedFailure: ImportedFailure) =
    exceptionNodeFor(importedFailure.failure)
        ?: messageNodeFor(importedFailure)


private
fun messageNodeFor(importedFailure: ImportedFailure) =
    FailureNode.Message(importedFailure.message)


private
fun exceptionNodeFor(it: JsFailure): FailureNode? =
    it.error?.let(FailureNode::Exception)


private
fun <T> treeModelFor(
    label: T,
    sequence: Sequence<List<T>>
): TreeView.Model<T> = TreeView.Model(
    treeFromTrie(
        label,
        Trie.from(sequence)
    )
)


private
fun <T> treeFromTrie(label: T, trie: Trie<T>): Tree<T> =
    Tree(label, subTreesFromTrie(trie))


private
fun <T> subTreesFromTrie(trie: Trie<T>): List<Tree<T>> =
    trie.entries.sortedBy { (label, _) -> label.toString() }.map { (label, subTrie) ->
        treeFromTrie(
            label,
            subTrie
        )
    }.toList()
